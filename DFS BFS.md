



![老婆](C:\Users\86158\Desktop\老婆.png)

# DFS  BFS

#### 搜索的定义

什么是搜索？

简单来说就是在**一堆东西**当中**一个一个一点一点地**找你需要的东西，比如在迷宫内求从起点到终点的最短路径长度。

具体来说即**穷举**一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。相关算法有枚举，**深搜(DFS)**，**广搜(BFS)**等。

## DFS(深度优先搜索)

深度优先搜索是一种用于遍历树或图的算法 。这个算法会尽可能深的搜索树的分支。其过程即：从某一个状态开始，**不断地**转移状态**直到无法转移**为止，然后**回退**到前一步状态，继续转移到其他状态，如此不断重复，直到找到最终解。

深搜的步骤可分为：**1.** **递归下去**  **2.** **回溯上来** 直到到达目标。而理解 **递归** 和 **回溯** 也是理解DFS的关键。

深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的 拓扑排序 表 ，利用拓扑排序表可以方便的解决很多相关的 图论 问题，如无权最长路径问题等等。

<img src="C:\Users\86158\Desktop\图片1.jpg" alt="dfs树" style="zoom:150%;" />

#### 向下递归

递归指函数中再次调用该函数自身的行为，而这样的函数也叫做递归函数。

**注意**递归函数需要边界条件结束递归。

比如斐波那契数列0, 1, 1, 2, 3, 5…中的第x个数可使用递归函数。

```c
#include<cstdio>
using namespace std;
int n;
double fibonacci(int x){if(x==0)return 0;if(x<3)return 1;return fibonacci(x-1)+fibonacci(x-2);}
int main(){
	scanf("%d",&n);
	printf("%lld",fibonacci(n));
	return 0;}
```

#### 向上回溯

回溯和枚举的思想相近,但不同在于枚举是将所有的情况都列举出来以后再一一筛选。

而回溯法在列举过程如果发现当前情况根本不可能存在答案(例如：到头了没路走了),就停止后续的所有工作,返回上一步进行新的尝试。

回溯是一种算法思想，它是通过用递归这一算法结构来实现的。



### 模板

因为$dfs$题型多，解法需根据题目灵活应变，在此只给出迷宫类问题的最基础的模板

```c
#include<bits/stdc++.h>
using namespace std;
int sx,sy,zx,zy,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0},dt[105][105],ans;
void dfs(int x,int y){
	if(x==zx&&y==zy){ans++;return;}
	for(int i=0;i<4;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if(判断条件)continue;
            dfs(xx,yy);
	}
}
int main(){
	dfs(sx,sy);
	printf("%d",ans);
	return 0;
}
```



### 例题：八皇后问题

有八个皇后,如何在 $8 \times 8$ 的棋盘中放置八个皇后,使得任意两个皇后都不在同一条横线、纵线或者斜线上，打印各个方案。![8](C:\Users\86158\Desktop\图片2.png)

#### 思路

/1.从棋盘的第一行开始，从第一个位置开始，依次判断当前位置是否能够放置皇后，判断的依据为：同该行之前的所有行中皇后的所在位置进行比较，如果在同一列，或者在同一条斜线上（斜线有两条，为正方形的两个对角线），都不符合要求，继续检验后序的位置。

/2.如果该行所有位置都不符合要求，则回溯到前一行，改变皇后的位置，继续搜索。

/3.如果搜索到最后一行，所有皇后摆放完毕，则直接打印出 8*8 的棋盘。并将棋盘恢复原样，避免影响下一次摆放。

#### 代码

```c
#include<cstdio>
using namespace std;
int ans=0,a[100];//a[z]=i:第z个皇后放在第i行
int e[100];//e[i]=0 第i行没放皇后
int r[100];//r[k]=0 第k条副对角线(/)没放皇后
int j[100];//j[k]=0 第k条主对角线(\)没放皇后
void fang(int z){
	if(z>8){
        ans++;
		for(int i=1;i<=8;i++)
		printf("%d ",a[i]);
		printf("\n");
		return;
	}
	else{
	for(int i=1;i<=8;i++){
		if((!e[i])&&(!r[i+z])&&(!j[z-i+n])){
			a[z]=i;
			e[i]=1;
			r[z+i]=1;
			j[z-i+n]=1;
		fang(z+1);
		e[i]=0;
		r[i+z]=0;
		j[z-i+n]=0;}
	}
}
}
int main(){
    fang(1);
    return 0;
}
```



### DFS非递归

而DFS的搜索顺序是先进后出与栈相同，因此可以用栈实现非递归版本的$dfs$。

写法是先定义一个栈,然后找到与最先出发点的所有邻接点,将他们入栈,同时标记这些点已被访问过。后面先是栈顶元素出栈重复上述步骤直至栈空。

队列呢？







## BFS(广度优先搜索)

广搜目的是系统地展开并检查图中的所有节点，以找寻结果。

广搜在面临一个路口时，将所有的岔路口都标记存储起来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作。一般用**队列**结构实现。

一般可以用它做什么呢？一个最直观经典的例子就是走迷宫，我们从起点开始，找出到终点的**最短路程**，很多最短路径算法(例如Dijkstra)就是基于广度优先的思想成立的。

<img src="C:\Users\86158\Desktop\图片3.jpg" alt="BFS" style="zoom: 67%;" />

#### 回顾队列

队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，即“先进先出”。

使用时需要头文件#include<queue>

定义一个队列：queue<int> q;​

入队：$q.push(a)$

出队：$q.pop()$

获得队首元素：$a=q.front()$

判断队列是否为空：$q.empty()==0 或 q.empty()!=0$

### 模板

```c
#include<cstdio>
#include<queue>
using namespace std;
queue<int>qx;
queue<int>qy;
int wx[5]={1,-1,0,0};
int wy[5]={0,0,-1,-1};
int main(){
	int dx,dy;
	map[x][y]=1;
	qx.push(x);
	qy.push(y);
	while(!qx.empty()){
		int a=qx.front();
		int b=qy.front();
		for(int i=0;i<4;i++){
			dx=a+wx[i];
			dy=b+wy[i];
			if(判断条件)continue;
			map[dx][dy]=1
			qx.push(dx);
			qy.push(dy);
		}
		qx.pop();
		qy.pop();
	}
}
```



因为广搜的题深搜一般都能做，在此就不再花时间举例，实在想练习可以去洛谷搜P1132 数字生成游戏。





